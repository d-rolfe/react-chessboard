[{"/Users/drolfe/dev/chess/src/index.js":"1","/Users/drolfe/dev/chess/src/reportWebVitals.js":"2","/Users/drolfe/dev/chess/src/App.js":"3","/Users/drolfe/dev/chess/src/Game.js":"4","/Users/drolfe/dev/chess/src/Board.js":"5","/Users/drolfe/dev/chess/src/ChessPiece.js":"6"},{"size":500,"mtime":1607298727732,"results":"7","hashOfConfig":"8"},{"size":362,"mtime":1607298727734,"results":"9","hashOfConfig":"8"},{"size":211,"mtime":1609533892222,"results":"10","hashOfConfig":"8"},{"size":10513,"mtime":1609827387647,"results":"11","hashOfConfig":"8"},{"size":1693,"mtime":1609828474390,"results":"12","hashOfConfig":"8"},{"size":1041,"mtime":1609781102309,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"a3xh78",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/drolfe/dev/chess/src/index.js",[],["28","29"],"/Users/drolfe/dev/chess/src/reportWebVitals.js",[],"/Users/drolfe/dev/chess/src/App.js",[],"/Users/drolfe/dev/chess/src/Game.js",["30"],"import { INVALID_MOVE } from 'boardgame.io/core';\nimport { \n    whitePawn,\n    whiteRook,\n    whiteKnight,\n    whiteBishop,\n    whiteQueen,\n    whiteKing,\n    blackPawn,\n    blackRook,\n    blackKnight,\n    blackBishop,\n    blackQueen,\n    blackKing,\n } from './ChessPiece';\n\nexport const ChessGame = {\n    // board[X][Y]\n    // x increases to the right\n    // y increases on the way down\n\n    setup: () => ({ \n        board: [\n            [blackRook, blackKnight, blackBishop, blackQueen, blackKing, blackBishop, blackKnight, blackRook],\n            [blackPawn, blackPawn, blackPawn, blackPawn, blackPawn, blackPawn, blackPawn, blackPawn],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [whitePawn, whitePawn, whitePawn, whitePawn, whitePawn, whitePawn, whitePawn, whitePawn],\n            [whiteRook, whiteKnight, whiteBishop, whiteQueen, whiteKing, whiteBishop, whiteKnight, whiteRook],\n        ],\n        selectedPiece: null,\n    }),\n\n    endIf: (G, ctx) => {\n        if (IsVictory(G.board)) {\n            return { winner: ctx.currentPlayer };\n        }\n    },\n\n    moves: {\n        selectPieceToMove: (G, ctx, y, x) => {\n            if (y === undefined || x === undefined) {\n                return INVALID_MOVE;\n            }\n            G.selectedPiece = { row: y, col: x }\n        },\n        movePiece: (G, ctx, yEnd, xEnd) => {\n            // note: start and end coords will always be within the board because they are mapped directly to the DOM\n            if (yEnd === undefined || xEnd === undefined) {\n                return INVALID_MOVE;\n            }\n            if (G.selectedPiece === null) {\n                return INVALID_MOVE;\n            }\n            let yStart = G.selectedPiece.row;\n            let xStart = G.selectedPiece.col;\n            let attackingPiece = G.board[yStart][xStart];\n            let defendingPiece = G.board[yEnd][xEnd];\n\n            if (isValidMove(ctx.currentPlayer, G.board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd)) {\n                // update board\n                G.board[yStart][xStart] = null;\n                G.board[yEnd][xEnd] = attackingPiece;\n                G.selectedPiece = null;\n                ctx.events.endTurn();\n            }\n            else {\n                // disallow move\n                G.selectedPiece = null;\n                return INVALID_MOVE;\n            }\n        }\n    }\n}\n\n// helper functions\nvar isValidMove = (currentPlayer, board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd) => {\n    // White moves first, so white = player 0, black = player 1\n    // ensure only can move players own pieces\n    if ( (currentPlayer === \"0\" ) && ( attackingPiece !== null && attackingPiece.team === \"black\" ) ) {\n        console.log(\"can't move other players pieces!!\");\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( attackingPiece !== null && attackingPiece.team === \"white\" ) ) {\n        console.log(\"can't move other players pieces!!\");\n        return false;\n    }\n    // ensure only can attack other players pieces\n    if ( (currentPlayer === \"0\" ) && ( defendingPiece !== null && defendingPiece.team === \"white\" ) ) {\n        console.log(\"can't friendly fire\");\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( defendingPiece !== null && defendingPiece.team === \"black\" ) ) {\n        console.log(\"can't friendly fire\");\n        return false;\n    }\n    if (attackingPiece === null) {\n        console.log(\"attacking piece is null!!!\")\n        return false;\n    }\n\n    switch(attackingPiece.type) {\n        case \"pawn\":\n            if (attackingPiece.team === \"white\") {\n                if (xStart === xEnd && yStart - 1 === yEnd && defendingPiece === null) {\n                    return true;  // white pawn moves up 1\n                }\n                else if ( (xStart === xEnd ) && ( yStart - 2 === yEnd ) && ( defendingPiece === null ) && ( yStart === 6) ) {\n                    return true;  // white pawn moves up 2\n                }\n                else if ((xStart + 1 === xEnd || xStart - 1 === xEnd) && (yStart - 1 === yEnd) && (defendingPiece !== null)) {\n                    return true; // white pawn attacks \n                }\n                else {\n                    console.log(\"Pawn attempts invalid move\");\n                    return false;  // invalid move\n                }\n            }\n            else if (attackingPiece.team === \"black\") {\n                if ( (xStart === xEnd ) && ( yStart + 1 === yEnd ) && ( defendingPiece === null )) {\n                    return true;  // black pawn moves down 1\n                }\n                else if ( (xStart === xEnd ) && ( yStart + 2 === yEnd ) && ( defendingPiece === null ) && ( yStart === 1) ) {\n                    return true;  // black pawn moves down 2\n                }\n                else if ((xStart + 1 === xEnd || xStart - 1 === xEnd) && (yStart + 1 === yEnd) && (defendingPiece !== null)) {\n                    return true; // black pawn attacks \n                }\n                else {\n                    console.log(\"Pawn attempts invalid move\");\n                    return false;  // invalid move\n                }\n            }\n            else {\n                console.log(\"Should never reach here\");\n                return false;  // should never reach here\n            }\n        case \"rook\":\n            if ( (yStart === yEnd) && (xStart !== xEnd) && (pathIsClearAlongRow(board, yStart, xStart, xEnd)) ) {\n                return true;\n            }\n            else if ( (xStart === xEnd) && (yStart !== yEnd) && (pathIsClearAlongColumn(board, xStart, yStart, yEnd)) ) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        // case \"B\" || \"b\":\n        //     let possibleMoves = []\n        //     if ( ( [yEnd, xEnd] in possibleMoves ) && ( pathIsClearAlongDiagonal(board, yStart, xStart, yEnd, xEnd)) ) {\n        //         return true\n        //     }\n        //     else {\n        //         return false\n        //     }\n        default:\n            console.log(\"Default case chosen\");\n            return false\n    }\n}\nvar isValidMove2 = (currentPlayer, board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd) => {\n    // White moves first, so white = player 0, black = player 1\n    // ensure only can move players own pieces\n    if ( (currentPlayer === \"0\" ) && ( \"prnbqk\".indexOf(attackingPiece) !== -1 ) ) {\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( \"PRNBQK\".indexOf(attackingPiece) !== -1 ) ) {\n        return false;\n    }\n    // ensure only can attack other players pieces\n    if ( (currentPlayer === \"0\" ) && ( \"PRNBQK\".indexOf(defendingPiece) !== -1 ) ) {\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( \"prnbqk\".indexOf(defendingPiece) !== -1 ) ) {\n        return false;\n    }\n    switch(attackingPiece) {\n        case \"P\":\n            if (xStart === xEnd && yStart - 1 === yEnd && defendingPiece === null) {\n                return true;  // white pawn moves up 1\n            }\n            else if ( (xStart === xEnd ) && ( yStart - 2 === yEnd ) && ( defendingPiece === null ) && ( yStart === 6) ) {\n                return true;  // white pawn moves up 2\n            }\n            else if ((xStart + 1 === xEnd || xStart - 1 === xEnd) && (yStart - 1 === yEnd) && (defendingPiece !== null)) {\n                return true // white pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"p\":\n            if ( (xStart === xEnd ) && ( yStart + 1 === yEnd ) && ( defendingPiece === null )) {\n                return true;  // black pawn moves down 1\n            }\n            else if ( (xStart === xEnd ) && ( yStart + 2 === yEnd ) && ( defendingPiece === null ) && ( yStart === 1) ) {\n                return true;  // black pawn moves down 2\n            }\n            else if ((xStart + 1 === xEnd || xStart - 1 === xEnd) && (yStart + 1 === yEnd) && (defendingPiece !== null)) {\n                return true // black pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"R\" || \"r\":\n            if ( (yStart === yEnd) && (xStart !== xEnd) && (pathIsClearAlongRow(board, yStart, xStart, xEnd)) ) {\n                return true\n            }\n            else if ( (xStart === xEnd) && (yStart !== yEnd) && (pathIsClearAlongColumn(board, xStart, yStart, yEnd)) ) {\n                return true\n            }\n            else {\n                return false\n            }\n        // case \"B\" || \"b\":\n        //     let possibleMoves = []\n        //     if ( ( [yEnd, xEnd] in possibleMoves ) && ( pathIsClearAlongDiagonal(board, yStart, xStart, yEnd, xEnd)) ) {\n        //         return true\n        //     }\n        //     else {\n        //         return false\n        //     }\n        default:\n            return false\n    }\n}\n\nvar pathIsClearAlongRow = (board, rowNum, xStart, xEnd) => {\n    let i;\n    for (i = xStart + 1; i < xEnd; i++) {\n        let square = board[rowNum][i]\n        if (square !== null) {\n            return false\n        }\n    }\n    return true;\n}\n\nvar pathIsClearAlongColumn = (board, colNum, yStart, yEnd) => {\n    let i;\n    for (i = yStart + 1; i < yEnd; i++) {\n        let square = board[colNum][i]\n        if (square !== null) {\n            return false\n        }\n    }\n    return true;\n}\n\n// TODO: better implementation might be to record pieces held 'hostage' and iterate through that to check if king has been captured.\nvar IsVictory = (board) => {\n    let i, j;\n    let seenWhiteKing = false;\n    let seenBlackKing = false;\n    for (i = 0; i < board.length; i++) {\n        let row = board[i];\n        for (j = 0; j< row.length; j++) {\n            if (board[i][j] !== null && board[i][j].type === \"king\" && board[i][j].team === \"white\") {\n                seenWhiteKing = true;\n            }\n            if (board[i][j] !== null && board[i][j].type === \"king\" && board[i][j].team === \"black\") {\n                seenBlackKing = true;\n            }\n        }\n    }\n    if (seenWhiteKing && seenBlackKing) {\n        return false;\n    }\n    else if (seenWhiteKing && !seenBlackKing) {\n        return true;\n    }\n    else if (!seenWhiteKing && seenBlackKing) {\n        return true;\n    }\n}","/Users/drolfe/dev/chess/src/Board.js",[],"/Users/drolfe/dev/chess/src/ChessPiece.js",[],{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","severity":1,"message":"36","line":163,"column":5,"nodeType":"37","messageId":"38","endLine":163,"endColumn":17},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"no-unused-vars","'isValidMove2' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]