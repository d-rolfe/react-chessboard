[{"/Users/drolfe/dev/chess/src/index.js":"1","/Users/drolfe/dev/chess/src/reportWebVitals.js":"2","/Users/drolfe/dev/chess/src/App.js":"3","/Users/drolfe/dev/chess/src/Game.js":"4","/Users/drolfe/dev/chess/src/Board.js":"5"},{"size":500,"mtime":1607298727732,"results":"6","hashOfConfig":"7"},{"size":362,"mtime":1607298727734,"results":"8","hashOfConfig":"7"},{"size":211,"mtime":1609533892222,"results":"9","hashOfConfig":"7"},{"size":6240,"mtime":1609631918295,"results":"10","hashOfConfig":"7"},{"size":1547,"mtime":1609696583213,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"a3xh78",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/drolfe/dev/chess/src/index.js",[],["24","25"],"/Users/drolfe/dev/chess/src/reportWebVitals.js",[],"/Users/drolfe/dev/chess/src/App.js",[],"/Users/drolfe/dev/chess/src/Game.js",["26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47"],"import { INVALID_MOVE } from 'boardgame.io/core';\n\nexport const ChessGame = {\n    // board[X][Y]\n    // x increases to the right\n    // y increases on the way down\n    // **White**\n    // K = white king\n    // Q = white queen\n    // R = white rook\n    // B = bishop\n    // N = knight\n    // P = pawn\n    // \n    // **black**\n    // k = black king\n    // q = black queen\n    // r = black rook\n    // b = bishop\n    // n = knight\n    // p = pawn\n\n    setup: () => ({ \n        board: [\n            [\"r\", \"n\", \"b\", \"q\", \"k\", \"b\", \"n\", \"r\"],\n            [\"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\"],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [\"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\"],\n            [\"R\", \"N\", \"B\", \"Q\", \"K\", \"B\", \"N\", \"R\"],\n        ],\n        selectedPiece: null,\n    }),\n\n    endIf: (G, ctx) => {\n        if (IsVictory(G.board)) {\n            return { winner: ctx.currentPlayer };\n        }\n    },\n\n    moves: {\n        selectPieceToMove: (G, ctx, y, x) => {\n            G.selectedPiece = { row: y, col: x }\n        },\n        movePiece: (G, ctx, yEnd, xEnd) => {\n            // note: start and end coords will always be within the board because they are mapped directly to the DOM\n            if (G.selectedPiece == null) {\n                return;\n            }\n            let yStart = G.selectedPiece.row;\n            let xStart = G.selectedPiece.col;\n            let attackingPiece = G.board[yStart][xStart];\n            let defendingPiece = G.board[yEnd][xEnd];\n\n            if (isValidMove(ctx.currentPlayer, G.board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd)) {\n                // update board\n                G.board[yStart][xStart] = null;\n                G.board[yEnd][xEnd] = attackingPiece;\n                G.selectedPiece = null;\n                ctx.events.endTurn();\n            }\n            else {\n                // disallow move\n                G.selectedPiece = null;\n                return INVALID_MOVE;\n            }\n        }\n    }\n}\n\n// helper functions\nvar isValidMove = (currentPlayer, board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd) => {\n    // White moves first, so white = player 0, black = player 1\n    // ensure only can move players own pieces\n    if ( (currentPlayer === \"0\" ) && ( \"prnbqk\".indexOf(attackingPiece) !== -1 ) ) {\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( \"PRNBQK\".indexOf(attackingPiece) !== -1 ) ) {\n        return false;\n    }\n    // ensure only can attack other players pieces\n    if ( (currentPlayer === \"0\" ) && ( \"PRNBQK\".indexOf(defendingPiece) !== -1 ) ) {\n        return false;\n    }\n    if ( (currentPlayer === \"1\" ) && ( \"prnbqk\".indexOf(defendingPiece) !== -1 ) ) {\n        return false;\n    }\n    switch(attackingPiece) {\n        case \"P\":\n            if (xStart == xEnd && yStart - 1 == yEnd && defendingPiece == null) {\n                return true;  // white pawn moves up 1\n            }\n            else if ( (xStart == xEnd ) && ( yStart - 2 == yEnd ) && ( defendingPiece == null ) && ( yStart == 6) ) {\n                return true;  // white pawn moves up 2\n            }\n            else if ((xStart + 1 == xEnd || xStart - 1 == xEnd) && (yStart - 1 == yEnd) && (defendingPiece != null)) {\n                return true // white pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"p\":\n            if ( (xStart == xEnd ) && ( yStart + 1 == yEnd ) && ( defendingPiece == null )) {\n                return true;  // black pawn moves down 1\n            }\n            else if ( (xStart == xEnd ) && ( yStart + 2 == yEnd ) && ( defendingPiece == null ) && ( yStart == 1) ) {\n                return true;  // black pawn moves down 2\n            }\n            else if ((xStart + 1 == xEnd || xStart - 1 == xEnd) && (yStart + 1 == yEnd) && (defendingPiece != null)) {\n                return true // black pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"R\" || \"r\":\n            if ( (yStart == yEnd) && (xStart != xEnd) && (pathIsClearAlongRow(board, yStart, xStart, xEnd)) ) {\n                return true\n            }\n            else if ( (xStart == xEnd) && (yStart != yEnd) && (pathIsClearAlongColumn(board, xStart, yStart, yEnd)) ) {\n                return true\n            }\n            else {\n                return false\n            }\n        // case \"B\" || \"b\":\n        //     let possibleMoves = []\n        //     if ( ( [yEnd, xEnd] in possibleMoves ) && ( pathIsClearAlongDiagonal(board, yStart, xStart, yEnd, xEnd)) ) {\n        //         return true\n        //     }\n        //     else {\n        //         return false\n        //     }\n        default:\n            return false\n    }\n}\n\nvar pathIsClearAlongRow = (board, rowNum, xStart, xEnd) => {\n    let i;\n    for (i = xStart + 1; i < xEnd; i++) {\n        let square = board[rowNum][i]\n        if (square != null) {\n            return false\n        }\n    }\n    return true;\n}\n\nvar pathIsClearAlongColumn = (board, colNum, yStart, yEnd) => {\n    let i;\n    for (i = yStart + 1; i < yEnd; i++) {\n        let square = board[colNum][i]\n        if (square != null) {\n            return false\n        }\n    }\n    return true;\n}\n\n// TODO: better implementation might be to record pieces held 'hostage' and iterate through that to check if king has been captured.\nvar IsVictory = (board) => {\n    let i, j;\n    let seenWhiteKing = false;\n    let seenBlackKing = false;\n    for (i = 0; i < board.length; i++) {\n        let row = board[i];\n        for (j = 0; j< row.length; j++) {\n            if (board[i][j] == \"K\") {\n                seenWhiteKing = true;\n            }\n            if (board[i][j] == \"k\") {\n                seenBlackKing = true;\n            }\n        }\n    }\n    if (seenWhiteKing && seenBlackKing) {\n        return false;\n    }\n    else if (seenWhiteKing && !seenBlackKing) {\n        return true;\n    }\n    else if (!seenWhiteKing && seenBlackKing) {\n        return true;\n    }\n}","/Users/drolfe/dev/chess/src/Board.js",[],{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","severity":1,"message":"53","line":92,"column":24,"nodeType":"54","messageId":"55","endLine":92,"endColumn":26},{"ruleId":"52","severity":1,"message":"53","line":92,"column":46,"nodeType":"54","messageId":"55","endLine":92,"endColumn":48},{"ruleId":"52","severity":1,"message":"53","line":95,"column":31,"nodeType":"54","messageId":"55","endLine":95,"endColumn":33},{"ruleId":"52","severity":1,"message":"53","line":95,"column":57,"nodeType":"54","messageId":"55","endLine":95,"endColumn":59},{"ruleId":"52","severity":1,"message":"53","line":95,"column":109,"nodeType":"54","messageId":"55","endLine":95,"endColumn":111},{"ruleId":"52","severity":1,"message":"53","line":98,"column":34,"nodeType":"54","messageId":"55","endLine":98,"endColumn":36},{"ruleId":"52","severity":1,"message":"53","line":98,"column":56,"nodeType":"54","messageId":"55","endLine":98,"endColumn":58},{"ruleId":"52","severity":1,"message":"53","line":98,"column":80,"nodeType":"54","messageId":"55","endLine":98,"endColumn":82},{"ruleId":"52","severity":1,"message":"53","line":105,"column":26,"nodeType":"54","messageId":"55","endLine":105,"endColumn":28},{"ruleId":"52","severity":1,"message":"53","line":105,"column":52,"nodeType":"54","messageId":"55","endLine":105,"endColumn":54},{"ruleId":"52","severity":1,"message":"53","line":108,"column":31,"nodeType":"54","messageId":"55","endLine":108,"endColumn":33},{"ruleId":"52","severity":1,"message":"53","line":108,"column":57,"nodeType":"54","messageId":"55","endLine":108,"endColumn":59},{"ruleId":"52","severity":1,"message":"53","line":108,"column":109,"nodeType":"54","messageId":"55","endLine":108,"endColumn":111},{"ruleId":"52","severity":1,"message":"53","line":111,"column":34,"nodeType":"54","messageId":"55","endLine":111,"endColumn":36},{"ruleId":"52","severity":1,"message":"53","line":111,"column":56,"nodeType":"54","messageId":"55","endLine":111,"endColumn":58},{"ruleId":"52","severity":1,"message":"53","line":111,"column":80,"nodeType":"54","messageId":"55","endLine":111,"endColumn":82},{"ruleId":"52","severity":1,"message":"53","line":118,"column":26,"nodeType":"54","messageId":"55","endLine":118,"endColumn":28},{"ruleId":"52","severity":1,"message":"56","line":118,"column":46,"nodeType":"54","messageId":"55","endLine":118,"endColumn":48},{"ruleId":"52","severity":1,"message":"53","line":121,"column":31,"nodeType":"54","messageId":"55","endLine":121,"endColumn":33},{"ruleId":"52","severity":1,"message":"56","line":121,"column":51,"nodeType":"54","messageId":"55","endLine":121,"endColumn":53},{"ruleId":"52","severity":1,"message":"53","line":170,"column":29,"nodeType":"54","messageId":"55","endLine":170,"endColumn":31},{"ruleId":"52","severity":1,"message":"53","line":173,"column":29,"nodeType":"54","messageId":"55","endLine":173,"endColumn":31},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation"]