[{"/Users/drolfe/dev/chess/src/index.js":"1","/Users/drolfe/dev/chess/src/reportWebVitals.js":"2","/Users/drolfe/dev/chess/src/App.js":"3","/Users/drolfe/dev/chess/src/Game.js":"4","/Users/drolfe/dev/chess/src/Board.js":"5"},{"size":500,"mtime":1607298727732,"results":"6","hashOfConfig":"7"},{"size":362,"mtime":1607298727734,"results":"8","hashOfConfig":"7"},{"size":211,"mtime":1609533892222,"results":"9","hashOfConfig":"7"},{"size":5600,"mtime":1609544138545,"results":"10","hashOfConfig":"7"},{"size":1188,"mtime":1609552126179,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"a3xh78",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/drolfe/dev/chess/src/index.js",[],["24","25"],"/Users/drolfe/dev/chess/src/reportWebVitals.js",[],"/Users/drolfe/dev/chess/src/App.js",[],"/Users/drolfe/dev/chess/src/Game.js",["26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48"],"import { INVALID_MOVE } from 'boardgame.io/core';\n\nexport const ChessGame = {\n    // board[X][Y]\n    // x increases to the right\n    // y increases on the way down\n    // **White**\n    // K = white king\n    // Q = white queen\n    // R = white rook\n    // B = bishop\n    // N = knight\n    // P = pawn\n    // \n    // **black**\n    // k = black king\n    // q = black queen\n    // r = black rook\n    // b = bishop\n    // n = knight\n    // p = pawn\n\n    setup: () => ({ \n        board: [\n            [\"r\", \"n\", \"b\", \"q\", \"k\", \"b\", \"n\", \"r\"],\n            [\"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\"],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [null, null, null, null, null, null, null, null],\n            [\"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\"],\n            [\"R\", \"N\", \"B\", \"Q\", \"K\", \"B\", \"N\", \"R\"],\n        ],\n        selectedPiece: null,\n    }),\n\n    turn: {\n        moveLimit: 1,\n    },\n\n    endIf: (G, ctx) => {\n        if (IsVictory(G.board)) {\n            return { winner: ctx.currentPlayer };\n        }\n    },\n\n    moves: {\n        selectPieceToMove: (G, ctx, y, x) => {\n            G.selectedPiece = { row: y, col: x }\n        },\n        movePiece: (G, ctx, yEnd, xEnd) => {\n            // note: start and end coords will always be within the board because they are mapped directly to the DOM\n            if (G.selectedPiece == null) {\n                return;\n            }\n            let yStart = G.selectedPiece.row;\n            let xStart = G.selectedPiece.col;\n            let attackingPiece = G.board[yStart][xStart];\n            let defendingPiece = G.board[yEnd][xEnd];\n\n            if (isValidMove(G.board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd)) {\n                // update board\n                G.board[yStart][xStart] = null;\n                G.board[yEnd][xEnd] = attackingPiece;\n            }\n            else {\n                // disallow move\n                console.log(\"invalid move\");\n                // return INVALID_MOVE;\n            }\n            G.selectedPiece = null;\n        }\n    }\n}\n\n// helper functions\nvar isValidMove = (board, attackingPiece, defendingPiece, yStart, xStart, yEnd, xEnd) => {\n    switch(attackingPiece) {\n        case \"P\":\n            if (xStart == xEnd && yStart - 1 == yEnd && defendingPiece == null) {\n                return true;  // white pawn moves up 1\n            }\n            else if ( (xStart == xEnd ) && ( yStart - 2 == yEnd ) && ( defendingPiece == null ) && ( yStart == 6) ) {\n                return true;  // white pawn moves up 2\n            }\n            else if ((xStart + 1 == xEnd || xStart - 1 == xEnd) && (yStart - 1 == yEnd) && (defendingPiece != null)) {\n                return true // white pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"p\":\n            if ( (xStart == xEnd ) && ( yStart + 1 == yEnd ) && ( defendingPiece == null )) {\n                return true;  // black pawn moves down 1\n            }\n            else if ( (xStart == xEnd ) && ( yStart + 2 == yEnd ) && ( defendingPiece == null ) && ( yStart == 1) ) {\n                return true;  // black pawn moves down 2\n            }\n            else if ((xStart + 1 == xEnd || xStart - 1 == xEnd) && (yStart + 1 == yEnd) && (defendingPiece != null)) {\n                return true // black pawn attacks \n            }\n            else {\n                return false  // invalid move\n            }\n        case \"R\" || \"r\":\n            if ( (yStart == yEnd) && (xStart != xEnd) && (pathIsClearAlongRow(board, yStart, xStart, xEnd)) ) {\n                return true\n            }\n            else if ( (xStart == xEnd) && (yStart != yEnd) && (pathIsClearAlongColumn(board, xStart, yStart, yEnd)) ) {\n                return true\n            }\n            else {\n                return false\n            }\n        // case \"B\" || \"b\":\n        //     let possibleMoves = []\n        //     if ( ( [yEnd, xEnd] in possibleMoves ) && ( pathIsClearAlongDiagonal(board, yStart, xStart, yEnd, xEnd)) ) {\n        //         return true\n        //     }\n        //     else {\n        //         return false\n        //     }\n        default:\n            return false\n    }\n}\n\nvar pathIsClearAlongRow = (board, rowNum, xStart, xEnd) => {\n    let i;\n    for (i = xStart + 1; i < xEnd; i++) {\n        let square = board[rowNum][i]\n        if (square != null) {\n            return false\n        }\n    }\n    return true;\n}\n\nvar pathIsClearAlongColumn = (board, colNum, yStart, yEnd) => {\n    let i;\n    for (i = yStart + 1; i < yEnd; i++) {\n        let square = board[colNum][i]\n        if (square != null) {\n            return false\n        }\n    }\n    return true;\n}\n\n// TODO: better implementation might be to record pieces held 'hostage' and iterate through that to check if king has been captured.\nvar IsVictory = (board) => {\n    let i, j;\n    let seenWhiteKing = false;\n    let seenBlackKing = false;\n    for (i = 0; i < board.length; i++) {\n        let row = board[i];\n        for (j = 0; j< row.length; j++) {\n            if (board[i][j] == \"K\") {\n                seenWhiteKing = true;\n            }\n            if (board[i][j] == \"k\") {\n                seenBlackKing = true;\n            }\n        }\n    }\n    if (seenWhiteKing && seenBlackKing) {\n        return false;\n    }\n    else if (seenWhiteKing && !seenBlackKing) {\n        return true;\n    }\n    else if (!seenWhiteKing && seenBlackKing) {\n        return true;\n    }\n}","/Users/drolfe/dev/chess/src/Board.js",[],{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":1,"column":10,"nodeType":"55","messageId":"56","endLine":1,"endColumn":22},{"ruleId":"57","severity":1,"message":"58","line":80,"column":24,"nodeType":"59","messageId":"60","endLine":80,"endColumn":26},{"ruleId":"57","severity":1,"message":"58","line":80,"column":46,"nodeType":"59","messageId":"60","endLine":80,"endColumn":48},{"ruleId":"57","severity":1,"message":"58","line":83,"column":31,"nodeType":"59","messageId":"60","endLine":83,"endColumn":33},{"ruleId":"57","severity":1,"message":"58","line":83,"column":57,"nodeType":"59","messageId":"60","endLine":83,"endColumn":59},{"ruleId":"57","severity":1,"message":"58","line":83,"column":109,"nodeType":"59","messageId":"60","endLine":83,"endColumn":111},{"ruleId":"57","severity":1,"message":"58","line":86,"column":34,"nodeType":"59","messageId":"60","endLine":86,"endColumn":36},{"ruleId":"57","severity":1,"message":"58","line":86,"column":56,"nodeType":"59","messageId":"60","endLine":86,"endColumn":58},{"ruleId":"57","severity":1,"message":"58","line":86,"column":80,"nodeType":"59","messageId":"60","endLine":86,"endColumn":82},{"ruleId":"57","severity":1,"message":"58","line":93,"column":26,"nodeType":"59","messageId":"60","endLine":93,"endColumn":28},{"ruleId":"57","severity":1,"message":"58","line":93,"column":52,"nodeType":"59","messageId":"60","endLine":93,"endColumn":54},{"ruleId":"57","severity":1,"message":"58","line":96,"column":31,"nodeType":"59","messageId":"60","endLine":96,"endColumn":33},{"ruleId":"57","severity":1,"message":"58","line":96,"column":57,"nodeType":"59","messageId":"60","endLine":96,"endColumn":59},{"ruleId":"57","severity":1,"message":"58","line":96,"column":109,"nodeType":"59","messageId":"60","endLine":96,"endColumn":111},{"ruleId":"57","severity":1,"message":"58","line":99,"column":34,"nodeType":"59","messageId":"60","endLine":99,"endColumn":36},{"ruleId":"57","severity":1,"message":"58","line":99,"column":56,"nodeType":"59","messageId":"60","endLine":99,"endColumn":58},{"ruleId":"57","severity":1,"message":"58","line":99,"column":80,"nodeType":"59","messageId":"60","endLine":99,"endColumn":82},{"ruleId":"57","severity":1,"message":"58","line":106,"column":26,"nodeType":"59","messageId":"60","endLine":106,"endColumn":28},{"ruleId":"57","severity":1,"message":"61","line":106,"column":46,"nodeType":"59","messageId":"60","endLine":106,"endColumn":48},{"ruleId":"57","severity":1,"message":"58","line":109,"column":31,"nodeType":"59","messageId":"60","endLine":109,"endColumn":33},{"ruleId":"57","severity":1,"message":"61","line":109,"column":51,"nodeType":"59","messageId":"60","endLine":109,"endColumn":53},{"ruleId":"57","severity":1,"message":"58","line":158,"column":29,"nodeType":"59","messageId":"60","endLine":158,"endColumn":31},{"ruleId":"57","severity":1,"message":"58","line":161,"column":29,"nodeType":"59","messageId":"60","endLine":161,"endColumn":31},"no-native-reassign",["62"],"no-negated-in-lhs",["63"],"no-unused-vars","'INVALID_MOVE' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation"]